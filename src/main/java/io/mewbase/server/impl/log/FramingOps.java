package io.mewbase.server.impl.log;


import io.mewbase.client.MewException;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.vertx.core.buffer.Buffer;

import java.util.zip.Adler32;
import java.util.Arrays;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

/**
 * The HeaderOps intended to manipulate Buffers (Vertx over Netty) in order to add/remove a header
 * from each Bson encoded event (record) that is written into the log
 *
 *
 * | Checksum - 32 bits        | checksum of body
 * | Body - Variable           | Body of single event
 * | Magic bytes - 128 bits    |
 *
 * Magic Bytes is a 128bit rep of a Secure Random generated byte array @see io.mewbase.util.RandomByteGenerator
 *
 */
public class FramingOps {

    private static final byte[] MAGIC_BYTES = {
            (byte)0xE6,(byte)0x1A,(byte)0xCD,(byte)0x2F,(byte)0x49,(byte)0xA9,(byte)0x42,(byte)0x8A,
            (byte)0x05,(byte)0x79,(byte)0x70,(byte)0xE8,(byte)0x86,(byte)0xA4,(byte)0xB8,(byte)0x9C
    };


    // frame layout
    public static final int CHECKSUM_SIZE = Integer.BYTES;
    public static final int MAGIC_SIZE = MAGIC_BYTES.length;
    // "header" is the checksum plus the size field of the body
    public static final int HEADER_SIZE = CHECKSUM_SIZE + Integer.BYTES;
    public static final int FRAME_SIZE = CHECKSUM_SIZE + MAGIC_SIZE;

    // Error Codes for MewException
    public static final int CHECKSUM_ERROR = 1;
    public static final int MAGIC_BYTES_ERROR = 2;

    private static final Checksum checksumOp = new CRC32();
    //private static final Checksum checksumOp = new Adler32();

    /**
     * Wrap the stateful checksum op in a threadsafe pure function.
     * For our purposes we force the checksum to never be 0
     */
    static synchronized int getNonZeroChecksum(byte[]  bytes) {
        checksumOp.reset();
        checksumOp.update(bytes, 0 , bytes.length);
        final int value = (int)checksumOp.getValue();
        return value == 0 ? 1 : value;
    }


    /**
     * Given a Vertx Buffer of bytes - add a Frame in the above format
     * using a netty zero copy compound buffer
     * @param in : Vertx Buffer of arbitrary bytes
     * @return Buffer with checksum in the Frame and magic number
     */
    public static Buffer frame(Buffer in)  {
            final ByteBuf header = Unpooled.buffer(CHECKSUM_SIZE);
            header.writeInt(getNonZeroChecksum(in.getBytes()));
            // zero copy compound buffer
            final ByteBuf footer = Unpooled.wrappedBuffer(MAGIC_BYTES);
            final ByteBuf framedEvent = Unpooled.wrappedBuffer(3, header, in.getByteBuf(), footer);
            return Buffer.buffer(framedEvent);
    }

    /**
     * Read a buffer with an encoded frame and perform various checks as the header is removed
     * @param in : Vertx Buffer with a header as described above.
     * @return : A buffer without the  header
     */
    public static Buffer unframe(Buffer in) {

        final int storedChecksum = in.getInt(0);
        final int bsonSize = in.getIntLE(CHECKSUM_SIZE);
        // size is part of the body
        final int bodyEndPos = CHECKSUM_SIZE+bsonSize;
        final byte[] bsonBody = in.getBytes(CHECKSUM_SIZE,bodyEndPos);

        // Ensure the body including the size header was not corrupt
        final int bodyChecksum = getNonZeroChecksum(bsonBody);
        if (bodyChecksum != storedChecksum) {
            throw new MewException("Checksum error - probable message corruption",CHECKSUM_ERROR);
        }

        // Ensure the magic bytes appear in the correct place at the end of the frame
        final byte[] storedMagic = in.getBytes(bodyEndPos, bodyEndPos+MAGIC_SIZE);
        if (!Arrays.equals(storedMagic, MAGIC_BYTES)) {
            throw new MewException("Magic bytes error - probable file corruption",MAGIC_BYTES_ERROR);
        }

        return Buffer.buffer(bsonBody);
    }


}
