package io.mewbase.server.impl.log;


import io.mewbase.client.MewException;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.vertx.core.buffer.Buffer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.zip.Adler32;
import java.util.Arrays;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

/**
 * The FramingOps intended to manipulate Buffers (Vertx over Netty) in order to add/remove a header
 * from each Bson encoded event (record) that is written into the log
 *
 *
 * | Checksum - 32 bits        | checksum of body
 * | Body - Variable           | Body of single event
 * | Magic bytes - 128 bits    |
 *
 * Magic Bytes is a 128bit rep of a Secure Random generated byte array @see io.mewbase.util.RandomByteGenerator
 *
 */
public class FramingOps {


    private final static Logger logger = LoggerFactory.getLogger(FramingOps.class);


    private static final byte[] MAGIC_BYTES = {
            (byte)0xE6,(byte)0x1A,(byte)0xCD,(byte)0x2F,(byte)0x49,(byte)0xA9,(byte)0x42,(byte)0x8A,
            (byte)0x05,(byte)0x79,(byte)0x70,(byte)0xE8,(byte)0x86,(byte)0xA4,(byte)0xB8,(byte)0x9C
    };

    // frame layout
    public static final int CHECKSUM_SIZE = Integer.BYTES;
    public static final int MAGIC_SIZE = MAGIC_BYTES.length;
    // "header" is the checksum plus the size field of the body
    public static final int HEADER_SIZE = CHECKSUM_SIZE + Integer.BYTES;
    public static final int FRAME_SIZE = CHECKSUM_SIZE + MAGIC_SIZE;


    private final Checksum checksumOp = new CRC32();

    /**
     * Wrap the stateful checksum op in pure function.
     * For our purposes we force the checksum to never be 0
     */
     private int getNonZeroChecksum(byte[]  bytes) {
        checksumOp.reset();
        checksumOp.update(bytes, 0 , bytes.length);
        final int value = (int)checksumOp.getValue();
        return value == 0 ? 1 : value;
    }


    /**
     * Given a Vertx Buffer of bytes - add a Frame in the above format
     * using a netty zero copy compound buffer
     * @param in : Vertx Buffer of arbitrary bytes
     * @return Buffer with checksum in the Frame and magic number
     */
    public Buffer frame(Buffer in)  {
            Buffer buff = Buffer.buffer( CHECKSUM_SIZE + in.length() + MAGIC_BYTES.length);
            final int checksum = getNonZeroChecksum(in.getBytes());
            return buff.appendInt(checksum).appendBuffer(in).appendBytes(MAGIC_BYTES);
    }

    /**
     * Read a buffer with an encoded frame and perform various checks as the header is removed
     * @param in : Vertx Buffer with a header as described above.
     * @return : A buffer without the  header
     */
    public Buffer unframe(Buffer in) {

        final int storedChecksum = in.getInt(0);
        final int bsonSize = in.getIntLE(CHECKSUM_SIZE);
        // size is part of the body
        final int bodyEndPos = CHECKSUM_SIZE+bsonSize;
        final byte[] bsonBody = in.getBytes(CHECKSUM_SIZE, bodyEndPos);

        // check the body including the size header was not corrupt
        final int bodyChecksum = getNonZeroChecksum(bsonBody);
        if (bodyChecksum != storedChecksum) {
            logger.error("Checksum error - probable log record corruption");
        }

        // check the magic bytes appear in the correct place at the end of the frame
        final byte[] storedMagic = in.getBytes(bodyEndPos, bodyEndPos+MAGIC_SIZE);
        if (!Arrays.equals(storedMagic, MAGIC_BYTES)) {
            logger.error("Magic bytes error - probable log file corruption");
        }

        return Buffer.buffer(bsonBody);
    }


}
